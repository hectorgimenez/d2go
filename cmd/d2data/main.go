package main

import (
	"encoding/json"
	"io"
	"log"
	"os"
	"slices"
	"text/template"
)

const templateSkillDesc = `// Code generated by d2data. DO NOT EDIT.
// source: cmd/d2data/d2data/skilldesc.json
package skill

var Desc = map[ID]Description{
{{- range $key, $value := . }}
    {{ $key }}: {Page: {{ $value.SkillPage }}, Row: {{ $value.SkillRow }}, Column: {{ $value.SkillColumn }}, ListRow: {{ $value.ListRow }}, IconCel: {{ $value.IconCel }}},
{{- end }}
}`

const templateSkills = `// Code generated by d2data. DO NOT EDIT.
// source: cmd/d2data/d2data/skills.json
package skill

var Skills = map[ID]Skill{
{{- range $key, $value := . }}
    {{ $key }}: {Name: "{{ $value.Name }}", ID: {{ $key }}, LeftSkill: {{ if eq $value.Leftskill 1 }}true{{ else }}false{{ end }}, RightSkill: {{ if eq $value.Rightskill 1 }}true{{ else }}false{{ end }}},
{{- end }}
}`

const templateLevels = `// Code generated by d2data. DO NOT EDIT.
// source: cmd/d2data/d2data/levels.json
package area

var Areas = map[ID]Area{
{{- range $key, $value := . }}
    {{ $key }}: {Name: "{{ $value.LevelName }}", ID: {{ $key }}, CanBeTerrorized: {{ $value.CanBeTerrorized }}},
{{- end }}
}`

const templateItems = `// Code generated by d2data. DO NOT EDIT.
// source: cmd/d2data/d2data/items.json
package item

var Desc = map[int]Description{
{{- range $key, $value := . }}
    {{ $value.ID }}: {Name: "{{ $value.Name }}", ID: {{ $value.ID }}, Code: "{{ $value.Code }}", NormalCode: "{{ $value.NormalCode }}", UberCode: "{{ $value.UberCode }}", UltraCode: "{{ $value.UltraCode }}", InventoryWidth: {{ $value.Width }}, InventoryHeight: {{ $value.Height }}, MinDefense: {{ $value.MinDefense }}, MaxDefense: {{ $value.MaxDefense }}},
{{- end }}
}`

type skillDesc struct {
	Skilldesc   string `json:"skilldesc"`
	SkillPage   int    `json:"SkillPage"`
	SkillRow    int    `json:"SkillRow"`
	SkillColumn int    `json:"SkillColumn"`
	ListRow     int    `json:"ListRow"`
	IconCel     int    `json:"IconCel"`
	StrName     string `json:"str name"`
	StrShort    string `json:"str short"`
	StrLong     string `json:"str long"`
	StrAlt      string `json:"str alt"`
}

type Skill struct {
	Leftskill  int    `json:"leftskill"`
	Rightskill int    `json:"rightskill"`
	Name       string `json:"skill"`
}

type Level struct {
	ID              int    `json:"Id"`
	LevelName       string `json:"LevelName"`
	CanBeTerrorized bool
}

type itemDesc struct {
	Name       string `json:"name"`
	Code       string `json:"code"`
	NormalCode string `json:"normcode"`
	UberCode   string `json:"ubercode"`
	UltraCode  string `json:"ultracode"`
	Width      int    `json:"invwidth"`
	Height     int    `json:"invheight"`
	ID         int    `json:"classid"`
	MinDefense int    `json:"minac"`
	MaxDefense int    `json:"maxac"`
}

// Generate static code from https://github.com/blizzhackers/d2data data files.
func main() {
	err := generateFromFile(templateSkillDesc, "cmd/d2data/d2data/skilldesc.json", "pkg/data/skill/skilldesc.go", &map[string]skillDesc{})
	if err != nil {
		log.Fatal(err)
	}

	err = generateFromFile(templateSkills, "cmd/d2data/d2data/skills.json", "pkg/data/skill/skills.go", &map[string]Skill{})
	if err != nil {
		log.Fatal(err)
	}

	err = generateAreas()
	if err != nil {
		log.Fatal(err)
	}

	err = generateFromFile(templateItems, "cmd/d2data/d2data/items.json", "pkg/data/item/items.go", &map[string]itemDesc{})
	if err != nil {
		log.Fatal(err)
	}
}

func generateFromFile(templateName, filePath, outPath string, unmarshallStruct interface{}) error {
	err := unmarshalFile(filePath, &unmarshallStruct)
	if err != nil {
		return err
	}

	t := template.Must(template.New("tpl").Parse(templateName))

	file, err := os.Create(outPath)
	if err != nil {
		return err
	}
	defer file.Close()

	return t.Execute(file, unmarshallStruct)
}

func generateAreas() error {
	levels := make(map[string]Level)
	err := unmarshalFile("cmd/d2data/d2data/levels.json", &levels)
	if err != nil {
		return err
	}

	terrorizedLevels := make([]int, 0)
	err = unmarshalFile("cmd/d2data/d2data/terrorized_levels.json", &terrorizedLevels)
	if err != nil {
		return err
	}

	for k, lvl := range levels {
		if slices.Contains(terrorizedLevels, lvl.ID) {
			lvl.CanBeTerrorized = true
			levels[k] = lvl
		}
	}

	t := template.Must(template.New("tpl").Parse(templateLevels))

	file, err := os.Create("pkg/data/area/areas.go")
	if err != nil {
		return err
	}
	defer file.Close()

	return t.Execute(file, levels)
}

func unmarshalFile(filePath string, unmarshallTo interface{}) error {
	jsonFile, err := os.Open(filePath)
	if err != nil {
		return err
	}
	defer jsonFile.Close()

	byteValue, err := io.ReadAll(jsonFile)
	if err != nil {
		return err
	}

	return json.Unmarshal(byteValue, &unmarshallTo)
}
